import os
from rich import print
from rich.text import Text
import time
import csv
import argparse
from rich.table import Table
from rich.live import Live
from rich.console import Console

console = Console()
terminal_width = console.width

class PCB:
    """
    This class generates a process control block (PCB) from information read in from 
    a data file. The attributes are passed to PCB as the pcb is
    generated by the readData method of the Simulator class. 
    """
    def __init__(self,pid,at,priority,cpubursts,iobursts):
        """
        Initializes a PCB instance
        """
        self.pid = pid                                                  # process ID
        self.priority = priority                                        # process priority
        self.arrivalTime = int(at)                                      # process arrival time
        self.cpubursts = [int(burst) for burst in cpubursts]            # list of CPU bursts
        self.iobursts = [int(burst) for burst in iobursts]              # list of IO bursts
        self.currBurstType = 'CPU'                                      # current burst type
        self.state='New'                                                # current state of the PCB
        self.waitTime = 0                                               # time spent in the wait queue
        self.readyTime = 0                                              # time spent in the ready queue
        self.cpuTime = sum(self.cpubursts)                              # total time spent in the CPU
        self.ioTime = sum(self.iobursts)                                # total time spent in IO
        
        self.sliceTimer = 0                                             # time spent in the CPU for Round Robin
        
        self.remainingCPUTime = 0                                       # remaining time in current CPU burst
        self.remainingIOTime = 0                                        # remaining time in current IO burst
        self.TAT = self.getTotalTime()                                  # total time in the system

    def setTimeEnter(self,clock):                                       # time PCB enters the CPU
        self.timeEnter = clock.currentTime()
        return self.timeEnter

    def setTimeExit(self,clock):                                        # time PCB exits the CPU
        self.timeExit = clock.currentTime()
        return self.timeExit
    
    def setTAT(self):                                                   # total time in the system
        self.TAT = self.timeExit - self.timeEnter
        return self.TAT

    def incrementReadyTime(self):                                       # time spent in the ready queue
        """
        increments the readyTime variable.  
        readyTime is the time PCB spends in the ready queue prior to entering CPU
        """
        self.readyTime += 1 

    def incrementWaitTime(self):                                        # time spent in the wait queue
        """
        increments the waitTime variable.   
        readyTime is the time PCB spends in the wait queue prior to entering IO
        """
        self.waitTime += 1       
   
    
    def changeState(self, new_state):                                   # current state of the PCB
        """
        changes state attribute which is the current queue location of the PCB
        """
        self.state = new_state

    def getCurrBurst(self):                                             # current burst type
        """ returns the current burst for the PCB"""
        if self.currBurstIs=='CPU':
            return self.cpubursts[self.currBurstIndex]
        elif self.currBurstIs =='IO':
            return self.iobursts[self.currBurstIndex]

    def getCurrentBurstTime(self):                                      # remaining time in current CPU burst
        return self.bursts[self.currBurstIndex]
        
    def getTotalTime(self):                                             # total time in the system
        """ 
        returns the total time the PCB spends in the system
        cpu time + io time + wait time + ready time + new time (1)
        """
        total = self.cpuTime + self.ioTime + self.readyTime + self.waitTime + 1
        self.TAT = total
        return total
    
    def getWaitTime(self):                                              # time spent in the wait queue
        """
        returns the total time PCB spend in the wait queue
        """
        return self.waitTime  
    
    def getReadyTime(self):                                             # time spent in the ready queue
        """
        returns the total time PCB spend in the ready (wait) queue
        """
        return self.readyTime  
    
    def cpu_ioRatio(self):                                              # ratio of CPU to IO times
        """
        returns the ratio of CPU to IO times
        """
        return round((self.cpuTime/self.ioTime),2)
    
    def run_idleRatio(self):                                            # ratio of run (CPU + IO ) time to (wait + ready) time
        """
        returns the ratio of run (CPU + IO ) time to (wait + ready) time
        """
        if self.waitTime + self.readyTime == 0:
            return 0
        else:
            return round((self.cpuTime + self.ioTime)/(self.readyTime + self.waitTime),2)
    
    def getcpu_util(self):
            """
            returns the cpu utilization ( % of time spent in CPU)
            """
            return round((self.cpuTime /self.getTotalTime()*100),2)
    
    def __str__(self):
        """
        Used only for initial testing
        Will print each PCB in the processes dictionary on a line as :
        PID # : process information.  Can do this as either a simple list of 
        information or an itemized list of all burst times. 
        """
        # simple return list
        #return f"[red]AT:[/red] {self.arrivalTime}, [blue]PID:[/blue] {self.pid}, [green]Priority:[/green] {self.priority:2}, [yellow]# CPU bursts:[/yellow] {self.noCpuBursts}, [yellow]CPU Time =[/yellow] {self.getTotCpuTime()} [magenta]# IO Bursts:[/magenta] {self.noIoBursts} [magenta]IO Time=[/magenta] {self.getTotIoTime()}"
        #burst itemized list
        return f"[red]AT:[/red] {self.arrivalTime}, [green]Priority:[/green] {self.priority:2}, [yellow]CPU:[/yellow] {self.cpubursts}, [magenta]IO:[/magenta] {self.iobursts}"
        
class SysClock:
    """
    This class creates a class-level variable called clock.
    The clock's value is used to drive the looping of the
    PCBs within the simulated scheduler.
    """
    _shared_state = {}
    def __init__(self):
        """
        creates the clock shared state variable
        """
        self.__dict__ = self._shared_state
        if not 'clock' in self.__dict__: 
            self.clock = 0

    def advanceClock(self, tick=1):
        """
        advances the clock +1
        """
        self.clock += tick
           
    def currentTime(self):
        """
        returns the currentTime (clock value)
        """
        return self.clock   
    
class Stats:
    """
    The class' methods display the stats associated with the movement of PCB
    through the schedular and generates a .csv output file.
    """    
    def __init__(self, processes,  clock, num_cpus, num_ios, simType='None', order="PID"):
        """
        Stats initialization
        """
        self.processes = processes
        self.symType =simType
        self.clock = clock
        self.num_cpus = num_cpus
        self.num_ios = num_ios
        self.statTable(clock)
        self.summaryTable(clock)
        self.statFileWriter(clock, simType)
    
    def statTable(self, clock)-> Table:
        """
        generates & displays a table showing the total clock time for completing all PCBs
        generates & displays a table with various stats from each PCB
        """


        #build a rich table
        # Create the table        
        sClock=str(self.clock.currentTime())

        sortedProcesses = sorted(self.processes, key=lambda pcb: int(pcb.pid), reverse=False)

        statTable = Table(show_header=True) # uses the add_column information to create column headings. 
        statTable.add_column(f'[bold blue]PID[/bold blue]', width=int(terminal_width*.1),justify='center')
        statTable.add_column(f'[bold][red]Priority[/red][/bold]',  width=int(terminal_width*.1),justify='center')
        statTable.add_column(f'[bold][cyan]Total Time[/cyan][/bold]',  width=int(terminal_width*.1),justify='center')
        statTable.add_column(f'[bold][magenta]Ready Time[/magenta][/bold]',  width=int(terminal_width*.1),justify='center')
        statTable.add_column(f'[bold][green]CPU Time[/green][/bold]',  width=int(terminal_width*.1),justify='center')
        statTable.add_column(f'[bold][magenta]Wait Time[/magenta][/bold]',  width=int(terminal_width*.1),justify='center')
        statTable.add_column(f'[bold][green]IO Time[/green][/bold]',  width=int(terminal_width*.1),justify='center')
        statTable.add_column(f'[bold][red]CPU Util[/red][/bold]',  width=int(terminal_width*.1),justify='center')
        statTable.add_column(f'[bold blue]CPU/IO[/bold blue]', width=int(terminal_width*.1),justify='center')
        statTable.add_column(f'[bold cyan]Run/Idle[/bold cyan]', width=int(terminal_width*.1),justify='center')
                             
        #statTable.add_row(f'Total Processes Run Time: [bold][yellow]{sClock}[/yellow][/bold]')
        for pcb in sortedProcesses:
            statTable.add_row(
                str(pcb.pid),
                str(pcb.priority),
                str(pcb.getTotalTime()),
                str(pcb.getReadyTime()),
                str(pcb.cpuTime),
                str(pcb.getWaitTime()),
                str(pcb.ioTime),
                str(pcb.getcpu_util()),
                str(pcb.cpu_ioRatio()),
                str(pcb.run_idleRatio())
                )
        print(f'[bold green]Process Run Attribute Data[/bold green]')       
        print(statTable)
        return statTable
    
    def statFileWriter(self, clock, simType='none'):
        """
        generates a .csv output file containing various stats from each PCB
        """ 
        # dictionary to match output filename to simulation run type
        sim_type_to_fname = {
            'SCPUInt': 'SCPU_stat_data.csv',
            'SIO': 'SIO_stat_data.csv',
            'LCPU': 'LCPU_stat_data.csv',
            'LIO': 'LIO_stat_data.csv',
            'HBCt':'HBCt_stat_data.csv',
            'LBCt':'LBCt_stat_data.csv',                
            }
         #Input file name equivalency lookup dictionary 
            # 'SCPUInt': '20 jobs, Long CPU burst, short IO bursts',
            # 'SIOInt': '20 jobs, Short CPU burst, long IO bursts',
            # 'MCPUInt': '50 jobs, Long CPU burst, short IO bursts',
            # 'MIOInt': '50 jobs, Short CPU burst, long IO bursts',
            # 'LCPUInt': '100 jobs, Long CPU burst, short IO bursts',
            # 'LIOInt': '100 jobs, Short CPU burst, long IO bursts',
            # 'SEven': '20 jobs, CPU -IO bursts equal lengths',
            # 'MEven': '50 jobs, CPU -IO bursts equal lengths',
            # 'LEven': '100 jobs, CPU -IO bursts equal lengths', 
        if simType=='None':
            outFileName ='SimStatsData.csv'
        else:
            outFileName=sim_type_to_fname.get(self.symType, f'{self.symType}_{time.strftime("%Y%m%d-%H%M%S")}.csv')
       
        with open(os.path.join('outputs', outFileName), 'w', newline='') as csvfile:
            fieldnames = ["Clock Time","Process ID", "Total Time", "Ready Time", "CPU Time", "IO Time", "Wait Time","CPU Util", "CPU/IO", "Run/Idle"]
            writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
            first_row = {"Clock Time": clock.currentTime()}
            writer.writerow(first_row)
            # Write the header row to the CSV file
            writer.writeheader()

            # Write data for each PCB
            for pcb in self.processes:
                data = {
                    'Process ID': pcb.pid,
                    'Total Time': pcb.getTotalTime(),
                    'Ready Time':pcb.getReadyTime(),
                    'CPU Time': pcb.cpuTime,
                    'Wait Time' : pcb.waitTime,
                    'IO Time' : pcb.ioTime,
                    'CPU Util':pcb.getcpu_util(),
                    'CPU/IO': pcb.cpu_ioRatio(),
                    'Run/Idle': pcb.run_idleRatio()                    
                        }
                writer.writerow(data) 
    def summaryTable(self, clock) -> Table:
        """
        generates & displays a table summarizing the various stats from the stats Table
        """
        #stats calcs
        total_cpu_time = 0
        total_wait_time =0
        total_ready_time=0
        total_tat_time = 0
        aveCpuUtil=''
        aveWaitTime=''
        aveReadyTime=''
        aveTat=''
        for pcb in self.processes:
            total_cpu_time += pcb.cpuTime
            total_wait_time += pcb.waitTime
            total_ready_time += pcb.readyTime
            total_tat_time += pcb.TAT
        cpus = str(self.num_cpus)
        ios=str(self.num_ios)
        aveCpuUtil = str(round(total_cpu_time/(self.num_cpus * clock.currentTime())*100,2))
        aveWaitTime = str(round((total_wait_time)/len(self.processes),2))
        aveReadyTime = str(round((total_ready_time)/len(self.processes),2))
        aveTat=str(round((total_tat_time)/len(self.processes),2))
        summaryTable  = Table(show_header=True) # uses the add_column information to create column headings.
        summaryTable.add_column(f'[bold][green]Summary Statistics Table[/bold][/green]',width=int(terminal_width*.8),justify='center') 
        summaryTable.add_row(f'Number of CPUs : {cpus}')
        summaryTable.add_row(f'Number of I/O Devices : {ios}')
        summaryTable.add_row(f"CPU Utilization: {aveCpuUtil} %")
        summaryTable.add_row(f"Avg Wait Time: {aveWaitTime}")
        summaryTable.add_row(f"Avg Ready Time: {aveReadyTime}")
        summaryTable.add_row(f"Avg TAT: {aveTat}")
        print(summaryTable)
        return summaryTable

class Simulator:    
    """
        This class is the main simulator operator
        methods to:
        read in the data from a file
        run the simulation loop
    """
    def __init__(self, datfile, alg="FCFS", num_cpus=1, num_ios=1, ts=5, sleep=0.1, outputfile=f'Sim_{time.strftime("%Y%m%d-%H%M%S")}.csv', order="PID"):
        """
        Simulator initialization
        """
        # Initialize the Parameters
        if alg == "RR":                                                                     # time slice for Round Robin
            self.timeSlice=int(ts)
        self.datfile = datfile                                                              # data file name                 
        self.num_cpus =int(num_cpus)                                                        # number of CPUs
        self.num_ios = int(num_ios)                                                         # number of IO devices     
        self.sleepTime = float(sleep)                                                       # time to sleep between each cycle
        self.outputfile = outputfile                                                        # output file name
        self.alg = alg                                                                      # algorithm type
        # Read in the data
        self.processes = []                                                                 # list of processes
        self.readData()                                                                     # read in the data

        # Initialize the Queues
        self.newQueue = []                                                                  # new queue
        self.readyQueue =[]                                                                 # ready queue
        self.CPUQueue =[]                                                                   # CPU queue
        self.IOQueue = []                                                                   # IO queue
        self.waitQueue = []                                                                 # Wait queue
        self.finishedQueue =[]                                                              # finished queue

        self.clock = SysClock()   
        self.simLoop()

    def getProcesses(self):
        """
        returns the processes dictionary
        """
        return self.processes
    
    def readData(self):
        """
        reads in data from a datafile containing PCB process parameters
        produces a dictionary named processes using the process ID number (pid)
        in each processes parameters as the key and instantiates an instance of a
        PCB class for each process, populating that PCB with the parameters for 
        arrival time, priority, cpu bursts list & io bursts list.
        """
        with open(self.datfile) as f:
            self.data = f.read().split("\n")

        for process in self.data:
            if len(process) > 0:
                parts = process.split()             # split the line into parts
                arrival = parts[0]                  # arrival time is the first part
                pid = parts[1]                      # pid is the second part
                priority = int(parts[2][1:])        # priority is the third part
                cpubursts = []                      # initialize the cpu burst list
                iobursts = []                       # initialize the io burst list
                
                # Split the remaining parts into cpu and io bursts
                for i in range(len(parts[3:])):
                    if i % 2 == 0:
                        cpubursts.append(parts[3:][i])
                    else:
                        iobursts.append(parts[3:][i])

                # Createa Dictionary of all processes with PID as key and values are PCBs
                self.processes.append(PCB(pid, arrival, priority, cpubursts, iobursts))
        return self.processes
    
    def simLoop(self):
        """
            This method runs the Schedular Simulation Loop
        """
        
        complete = False            # flag to indicate if the simulation is complete
        loopIteration = 0           # loop iteration counter

        # Begin Simulation Loop
        while not complete:         # loop until all processes are complete
            print_statements = []
            # Increment times for readyQueue and waitQueue PCBs
            if self.readyQueue:
                for pcb in self.readyQueue:
                    pcb.changeState('Ready')
                    if self.alg == "PB":
                        self.readyQueue.sort(key=lambda x: x.priority, reverse=True)
                    pcb.incrementReadyTime()
            
            if self.waitQueue:
                for pcb in self.waitQueue:
                    pcb.changeState('Wait')
                    pcb.incrementWaitTime()

            # Move anything from New Queue to Ready Queue
            if self.newQueue:
                for pcb in self.newQueue:
                    pcb.changeState('Ready')
                    self.readyQueue.append(pcb)
                    print_statements.append(f'FCB {pcb.pid} added to Ready Queue')
                self.newQueue = []

            # Check for new proccesses if pcb arrival time == clock time
            # Move any new processes to the newQueue
            for pcb in self.processes:
                if pcb.arrivalTime == self.clock.currentTime():
                    self.newQueue.append(pcb)
                    # self.processes.remove(pcb)
                    print_statements.append(f'PCB {pcb.pid} added to New Queue')
                    pcb.changeState('New')

            # Decrement current CPU and IO processes bursts values
            if self.CPUQueue:
                for pcb in self.CPUQueue:
                    if pcb.cpubursts:
                        pcb.cpubursts[0] -=1
                        pcb.remainingCPUTime = pcb.cpubursts[0]
                        if self.alg == "RR":
                            pcb.sliceTimer += 1

            if self.IOQueue:
                for pcb in self.IOQueue:
                    if pcb.iobursts:
                        pcb.iobursts[0] -=1
                        pcb.remainingIOTime = pcb.iobursts[0]

            # Check processes in CPU (FCFS)
            if self.alg == "FCFS" or self.alg == "PB":
                if self.CPUQueue:
                    for pcb in self.CPUQueue:
                        if pcb.cpubursts[0] <= 0:
                            if len(pcb.cpubursts) <= 1:
                                pcb.changeState('Finished')
                                print_statements.append(f'PCB {pcb.pid} finished')
                                self.finishedQueue.append(pcb)
                                self.CPUQueue.remove(pcb)
                            else:
                                self.waitQueue.append(pcb)
                                print_statements.append(f'PCB {pcb.pid} added to Wait Queue')
                                pcb.changeState('Wait')
                                if pcb.cpubursts:
                                    pcb.cpubursts.pop(0)
                    self.CPUQueue = [pcb for pcb in self.CPUQueue if pcb.state == "CPU"]

                    # Move Ready Queue to CPU Queue
                    if self.readyQueue and loopIteration >=1 and (not self.CPUQueue or len(self.CPUQueue)< self.num_cpus):
                        num_to_assign = min(self.num_cpus - len(self.CPUQueue), len(self.readyQueue))
                        next_processes = self.readyQueue[:num_to_assign]
                        self.CPUQueue.extend(next_processes)
                        for pcb in next_processes:
                            pcb.changeState('CPU')
                            print_statements.append(f'PCB {pcb.pid} added to CPU')
                        self.readyQueue = self.readyQueue[num_to_assign:]
                    else:
                        if loopIteration >=1 and not self.readyQueue and not self.IOQueue and not self.CPUQueue and not self.waitQueue:
                            complete = True
                else:
                    if self.readyQueue and (not self.CPUQueue or len(self.CPUQueue) < self.num_cpus):
                        num_to_assign = min(self.num_cpus - len(self.CPUQueue), len(self.readyQueue))
                        next_processes = self.readyQueue[:num_to_assign]
                        self.CPUQueue.extend(next_processes)
                        for pcb in next_processes:
                            pcb.changeState('CPU')
                            print_statements.append(f'PCB {pcb.pid} added to CPU')
                        self.readyQueue = self.readyQueue[num_to_assign:]
                    else:
                        if loopIteration > 1 and not self.readyQueue and not self.IOQueue and not self.CPUQueue and not self.waitQueue:
                            complete = True

            elif self.alg == "RR":
                if self.CPUQueue:
                    for pcb in self.CPUQueue:
                        if pcb.cpubursts[0] == 0:
                            if len(pcb.cpubursts) <= 1:
                                pcb.changeState('Finished')
                                pcb.setTimeExit(self.clock)
                                pcb.getTotalTime()
                                self.finishedQueue.append(pcb)
                                pcb.cpubursts.pop(0)
                            else:
                                self.waitQueue.append(pcb)
                                pcb.changeState('Wait')
                                if pcb.cpubursts:
                                    pcb.cpubursts.pop(0)
                        else:
                            if pcb.cpubursts:
                                if pcb.cpubursts[0] != 0:
                                    if pcb.sliceTimer == self.timeSlice:
                                        self.readyQueue.append(pcb)
                                        pcb.changeState('Ready')
                                        pcb.sliceTimer = 0
                                else:
                                    self.waitQueue.append(pcb)
                                    pcb.changeState('Wait')
                                    if pcb.cpubursts:
                                        pcb.cpubursts.pop(0)
                    
                    self.CPUQueue = [pcb for pcb in self.CPUQueue if pcb.state == "CPU"]
                    
                    if self.readyQueue and (not self.CPUQueue or len(self.CPUQueue) < self.num_cpus):   # are processes in readyqueue & is CPU not full
                        num_to_assign = min(self.num_cpus - len(self.CPUQueue), len(self.readyQueue))
                        next_processes = self.readyQueue[:num_to_assign]                                # get # of process from ready queue needed to fill CPU
                        self.CPUQueue.extend(next_processes)                                            # move next processes to the CPU 
                        for pcb in next_processes:
                            pcb.changeState('CPU')
                            print_statements.append(f'PCB {pcb.pid} added to CPU')
                        self.readyQueue = self.readyQueue[num_to_assign:] 
                    elif self.CPUQueue and self.IOQueue and not self.readyQueue:                        # if ready is empty, but IO still has processes continue
                        pass
                    else:
                        if loopIteration > 1 and not self.readyQueue and not self.IOQueue and not self.CPUQueue and not self.waitQueue:
                            complete=True     
                else:
                    if self.readyQueue and (not self.CPUQueue or len(self.CPUQueue) < self.num_cpus):
                        num_to_assign = min(self.num_cpus - len(self.CPUQueue), len(self.readyQueue))
                        next_processes = self.readyQueue[:num_to_assign]
                        self.CPUQueue.extend(next_processes)
                        for pcb in next_processes:
                            pcb.changeState('CPU')
                        self.readyQueue = self.readyQueue[num_to_assign:]
                    elif loopIteration > 1 and not self.readyQueue and not self.IOQueue and not self.CPUQueue and not self.waitQueue:
                        complete=True 

            # Check if any PCBs in IO Queue are finished
            if self.IOQueue:
                next_IOproccesses = []

                completeIOprocessses = [pcb for pcb in self.IOQueue if pcb.iobursts[0] == 0]

                self.IOQueue = [pcb for pcb in self.IOQueue if pcb.iobursts[0] != 0]
                for pcb in self.IOQueue:
                    pcb.remainingIOTime = pcb.iobursts[0]
                
                for pcb in completeIOprocessses:
                    pcb.changeState('Ready')
                    print_statements.append(f'PCB {pcb.pid} added to Ready Queue')
                self.readyQueue.extend(completeIOprocessses)

                for pcb in completeIOprocessses:
                    if pcb.iobursts[0] == 0:
                        pcb.iobursts.pop(0)
                completeIOprocessses.clear()
            
            if self.waitQueue and (not self.IOQueue or len(self.IOQueue) < self.num_ios):
                if self.alg == "PB":
                    self.waitQueue.sort(key=lambda x: x.priority, reverse=True)
                num_to_assign = min(self.num_ios - len(self.IOQueue), len(self.waitQueue))
                next_processes = self.waitQueue[:num_to_assign]
                self.IOQueue.extend(next_processes)
                for pcb in next_processes:
                    pcb.changeState('IO')
                    print_statements.append(f'PCB {pcb.pid} added to IO')
                self.waitQueue = self.waitQueue[num_to_assign:]

            
            loopIteration +=1
            clock = self.clock.currentTime()
            os.system('cls' if os.name == 'nt' else 'clear')

            with Live(self.headTable(self.datfile, self.num_cpus, self.num_ios)) as live:
                live.update(self.headTable(self.datfile, self.num_cpus, self.num_ios))

            with Live(self.generateTable(clock)) as live:
                live.update(self.generateTable(clock))

            for statement in print_statements:
                print(statement)
            time.sleep(self.sleepTime)
            self.clock.advanceClock(1)
    # Methods for output visualization
    def make_row(self, queue):
        """ 
        Called by the generateTable method to build lists containing all proceses currently within a given queue columns. 
        Returns the jobs list to the generateTable method to be added as row in visualization table for processes. 
        """
        jobs =''
        if queue=='New'and self.newQueue:
            for pcb in self.newQueue:
                jobs += str(f"[bold][[/bold][bold blue]{pcb.pid}[/bold blue], [red]P{pcb.priority}[/red][bold]][/bold]")
            return [jobs]
        elif queue=='Ready' and self.readyQueue:
            for pcb in self.readyQueue:
                jobs += str(f"[bold][[/bold][bold blue]{pcb.pid}[/bold blue], [red]P{pcb.priority}[/red], [magenta]{pcb.readyTime}[/magenta][bold]][/bold]" )    
            return [jobs]
        elif queue=='Wait'and self.waitQueue:
            for self.pcb in self.waitQueue:
                jobs += str(f"[bold][[/bold][bold blue]{self.pcb.pid}[/bold blue], [red]P{self.pcb.priority}[/red], [magenta]{self.pcb.waitTime}[/magenta][bold]][/bold]" )    
            return [jobs]
        elif queue=='CPU' and self.CPUQueue:
            for pcb in self.CPUQueue:
                jobs += str(f"[bold][[/bold][bold blue]{pcb.pid}[/bold blue], [red]P{pcb.priority}[/red], [green]{pcb.remainingCPUTime}[/green][bold]][/bold]" )    
            return [jobs]
        elif queue=='IO' and self.IOQueue:
            for pcb in self.IOQueue:
                jobs += str(f"[bold][[/bold][bold blue]{pcb.pid}[/bold blue], [red]P{pcb.priority}[/red], [green]{pcb.remainingIOTime}[/green][bold]][/bold]" )    
            return [jobs]
        elif queue=='Finished'and self.finishedQueue:
            for pcb in self.finishedQueue:
                jobs += str(f"[bold][[/bold][bold blue]{pcb.pid}[/bold blue][bold]][/bold]")
            return [jobs] 
        else:
            return ['']
    
    def headTable(self, input, num_cpus, num_ios) -> Table:
        cpus=str(num_cpus)
        ios=str(num_ios)
        input=str(input)

        headTable = Table(show_header=True, width=int(terminal_width*.9), )
        headTable.add_column(f'[bold green]Process Progress Table[/bold green]', justify = "center")
        
        if self.alg != "RR":
            self.timeSlice = -1
        algorithms = {
            "RR": f"Round Robin with Time Slice {self.timeSlice}",
            "FCFS": "First Come First Serve w/o Priority",
            "PB": "First Come First Serve with Priority "
        }
        headTable.add_row(f'[bold blue]Algorithm Type: [/][bold cyan]{algorithms[self.alg]}[/]')
        headTable.add_row(f'[bold red]CPUs: [/][bold magenta] {cpus}[/]')
        headTable.add_row(f'[bold dark_red]IO devices: [/][bold purple4] {ios}[/]')
        headTable.add_row(f'[bold blue1]Input File Name:  [/][bold deep_sky_blue1] {input}[/]')
        return headTable

    def generateTable(self,clock) -> Table:
        """ 
            returns a rich table that displays all the queue contents.
            make_row returns a list of processes in each queue. 
        """  
        # Create the table
        qClock=str(self.clock.currentTime())
        table = Table(show_header=True,width=int(terminal_width*.9)) # uses the add_column information to create column headings. 
        table.add_column(f'[bold][yellow]Clock[/yellow][/bold]', width=int(terminal_width*.1))
        table.add_column(f'[bold][cyan]Queue[/cyan][/bold]',  width=int(terminal_width*.1))
        table.add_column(f'[bold blue]Process[/bold blue], [bold red]Priority[/bold red], [bold green]Burst Time[/bold green]/[bold magenta]Idle Time[/bold magenta]', width=int(terminal_width*.8))
        
        table.add_row('','New',*self.make_row("New"), end_section=True)
        table.add_row('','Ready',*self.make_row("Ready"), end_section=True)
        table.add_row(qClock,'CPU',*self.make_row("CPU"), end_section=True)
        table.add_row('','Wait',*self.make_row("Wait"), end_section=True)
        table.add_row('','IO',*self.make_row("IO"), end_section=True)
        table.add_row('','Done',*self.make_row("Finished"), end_section=True)
        return table

def main(datafile, num_cpus=1, num_ios=1, alg="FCFS", ts=5, sleep=0.01, outputfile="SimStatsData.csv", order="PID"):
    sim = Simulator(datafile, alg, num_cpus, num_ios, ts, sleep, outputfile, order)
    print(f'\n[bold][red] All processes have terminated[/red][/bold]\n')
    Stats(sim.getProcesses(), sim.clock, num_cpus, num_ios, alg, datafile)

if __name__ == '__main__':
    # Default values
    filename = "datafile.dat"
    algorithm = "FCFS"
    cpu = 1
    ios = 1
    ts = 10
    sleep = 0.1
    #order = "PID"
    
    output = "output.dat"

    parser = argparse.ArgumentParser()
    parser.add_argument("filename", help="The name of the file to read from")
    #parser.add_argument("-r", "--order", help="The order in which to run the processes", type=str)
    parser.add_argument("-a", "--algorithm", help="The algorithm to use for the simulation")
    parser.add_argument("-c", "--cpu", help="The number of CPUs to simulate", type=int)
    parser.add_argument("-i", "--ios", help="The number of I/O devices to simulate", type=int)
    parser.add_argument("-t", "--ts", help="The time slice to use for the Round Robin algorithm", type=int)
    parser.add_argument("-s", "--sleep", help="The amount of time to sleep between each cycle", type=float)
    parser.add_argument("-o", "--output", help="The name of the output file", type=str)
    

    args = parser.parse_args()
    
    filename = args.filename if args.filename else filename
    algorithm = args.algorithm if args.algorithm else algorithm
    cpu = args.cpu if args.cpu else cpu
    ios = args.ios if args.ios else ios
    ts = args.ts if args.ts else ts
    sleep = args.sleep if args.sleep else sleep
    output = args.output if args.output else output
    #order = args.order if args.order else order
    
    if algorithm not in ["FCFS", "RR", "PB"]:
        print("Invalid algorithm. Please choose from the following: FCFS, RR")
    else:
        if output:
            main(filename, cpu, ios, algorithm, ts, sleep, output)
        else:
            main(filename, cpu, ios, algorithm, ts, sleep)            
 
 
    