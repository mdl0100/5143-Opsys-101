# CPU Scheduler Simulation
---

#### 17 Nov 2023
#### 5143 CPU Scheduler Project 

#### Group Members
 
- Marcos Lopez
- Patrick Mitchell
- Jon Scales

### Overview:
#### States
This is a project written in python that simulates a CPU scheduler which moves simulated computational processes (PCBs) through a series of 5 states: New -> Ready -> CPU -> Wait -> IO -> Terminated.  Processes in IO will return to the Ready state to await further CPU processing. Each system state is simulated by list container.  Each PCB is simulated with an ID, a priority, a set of CPU bursts and a set of IO bursts and a system arrival time.  CPU & IO bursts simulate processor time within the CPU state or access to peripheral devices within the IO states. The simulation runs as a loop with each cycle of the loop acting as a "clock tick" of the system clock. PCBs will be added to the new state in accordance with their associated system arrival time.  

#### Processes (PCBs)
Multiple batches of simulated processes were run through the simulation.  These batches take the form of .dat files generated by the generate.py program.  We utilized 9 different process batches as follows: 

    SEven - 20 PCBs with 15-20 CPU & IO bursts of approximately equal lengths ranging from 10-18 clock ticks/burst
    SCPUInt = 20 PCBs with 15-20 CPU & IO bursts of with the CPU bursts 4-7 times longer than the IO burst lengths 
    SIOInt = 20 PCBs with 15-20 CPU & IO bursts of with the IO bursts ~2 times longer than the CPU burst lengths 
    MEven & LEven - as above for SEven but with 50 or 100 PCBs respectivily
    MCPUInt & MCPUInt - as above for SCPUInt but with 50 or 100 PCBs respectivily
    MIOInt & LIOInt - as above for SIOInt but with 50 or 100 PCBs respectivily

#### Scheduler Algorithms & Implementation Steps
Three scheduler algorithms were implemented.  First-come-first-served (FCFS), priority-based-FCFS (PB), and round-robin (RR) using a time slice. Each type of algorithm was implemented with the ability to vary the number of CPU and IO states, vary the alloted cpu timeslic as well as augment priorities to prevent starvation of PCBs with lower priorities. 

During each clock tick the following events occur:
1. The time of PCBs in the wait or ready states is incremented +1
2. Any PCB in the new state if moved to ready
3. Any newly arrived PCBs are added to the new state
4. Currently running bursts of PCBs in the CPU and IO states are decremented -1
5. For round robin simulations, CPU processes are checked to see if their timeslice is expired and returned to the ready state
6. Any PCB in CPU or IO which has completed its current burst is moved to the wait or ready state respectively
7. Based on available CPU state slots, PCBs in the ready state are added to the CPU 
8. Based on available IO state slots, PCBs in the wait state are added to the IO 
9. Information for each PCB is displayed to the terminal with rich table
10. The clock is incremented +1

The simulation runs as a while loop with the end condition as all states (lists) except Terminated are empty. 

#### Simulation Output
The following information is collected for each PCB regarding its progression through the simulated system:

    -Turn around time (total time in system)
    -Time in wait state
    -Time in ready state
    -CPU/IO ratio (gives a measure of the CPU vs IO intensity of the PCB)
    -CPU utilization (time PCB spent in CPU vs other states)

For each PCB batch, aggreagated information was calculated from the individual PCB data to include:

    -Average time in system for PCBs
    -Average wait time
    -Average ready time
    -CPU utilization (percent of time CPU was occupied by running PCBs)

Each of these data points were displayed both to the terminal as well as written to a .csv file named in accordance to the algorithm type, PCB batch type, CPU#, IO# and date.  The output files will be used to generate graphical representation of the simulations to give comparative feedback on algorithm efficiency under varying situations (i.e. CPU intensive, or CPU number).

### Required Packages
- Rich Table
- Rich Console
- Rich

### Scheduler Simulation Program Files ###
|    Program    |                Description                 | Author |
| :-----------: | :----------------------------------------: | :----: |
|   [sim.py]    |          main simulation program           |        |
| [sim_loop.py] | Actual implementation of the CPU simulator |
|  [SEven.dat]  | Small dataset with even bursts simulation  |        |
| [SCPUInt.dat] |        Small CPU Intensive Dataset         |
| [SIOInt.dat]  |        Small I/O Intensive Dataset         |


 
#### Instructions

- Run [sim.py] program with parameters from the list below. 
                                     
### Commands List: ###
The sim.py is run from the command line with these parameters : 

|     Parameter     |     Syntax     |                                notes                                |
| :---------------: | :------------: | :-----------------------------------------------------------------: |
| PCB data filename |   SEven.dat    |                              required                               |
|  algorithm type   | -a,  --algorithm |                 default FCFS, also can be RR or PB                  |
|    cpu number     |   -c,  --cpus    |                        optional (default 1)                         |
|     io number     |    -i,  --ios    |                        optional (default 1)                         |
|     timeslice     |    -t,  --ts     |                otional (default 5) only used for RR                 |
| simulation speed  |   -s,  --sleep   |                       optional (default .01)                        |
|  output filename  |  -o,  --output   | optional (default = algorithmtype_inputtype_cpu#_IO#_timestamp.csv) |


### References
- Dr. Giffin's code was a helpful starting point.
- Various authors made use of either ChatGPT or CoPilot for formatting, comments, or direction
